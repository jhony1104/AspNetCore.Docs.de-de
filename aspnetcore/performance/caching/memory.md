---
title: Speicher interne Speicherung in ASP.net Core
author: rick-anderson
description: Erfahren Sie, wie Sie Daten im Arbeitsspeicher in ASP.NET Core zwischenspeichern können.
ms.author: riande
ms.custom: mvc
ms.date: 02/02/2020
no-loc:
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: performance/caching/memory
ms.openlocfilehash: 8eec361efbc3c7dca6c0bef65b6f6b40b3b46798
ms.sourcegitcommit: d65a027e78bf0b83727f975235a18863e685d902
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/26/2020
ms.locfileid: "85404612"
---
# <a name="cache-in-memory-in-aspnet-core"></a><span data-ttu-id="3407d-103">Speicher interne Speicherung in ASP.net Core</span><span class="sxs-lookup"><span data-stu-id="3407d-103">Cache in-memory in ASP.NET Core</span></span>

::: moniker range=">= aspnetcore-3.0"

<span data-ttu-id="3407d-104">Von [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo)und [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="3407d-104">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="3407d-105">[Anzeigen oder Herunterladen von Beispielcode](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/3.0sample) ([Vorgehensweise zum Herunterladen](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="3407d-105">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/3.0sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="3407d-106">Grundlagen zum Caching</span><span class="sxs-lookup"><span data-stu-id="3407d-106">Caching basics</span></span>

<span data-ttu-id="3407d-107">Die Zwischenspeicherung kann die Leistung und Skalierbarkeit einer APP erheblich verbessern, indem die zum Generieren von Inhalten erforderliche Arbeit reduziert wird.</span><span class="sxs-lookup"><span data-stu-id="3407d-107">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="3407d-108">Das Caching funktioniert am besten mit Daten, die sich nur selten ändern **und** sehr aufwendig generiert werden.</span><span class="sxs-lookup"><span data-stu-id="3407d-108">Caching works best with data that changes infrequently **and** is expensive to generate.</span></span> <span data-ttu-id="3407d-109">Durch das Zwischenspeichern wird eine Kopie der Daten erstellt, die viel schneller als die Quelle zurückgegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="3407d-109">Caching makes a copy of data that can be returned much faster than from the source.</span></span> <span data-ttu-id="3407d-110">Apps sollten so geschrieben und getestet werden, dass Sie **nie** von zwischengespeicherten Daten abhängen.</span><span class="sxs-lookup"><span data-stu-id="3407d-110">Apps should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="3407d-111">ASP.net Core unterstützt mehrere verschiedene Caches.</span><span class="sxs-lookup"><span data-stu-id="3407d-111">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="3407d-112">Der einfachste Cache basiert auf [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span><span class="sxs-lookup"><span data-stu-id="3407d-112">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span></span> <span data-ttu-id="3407d-113">`IMemoryCache`stellt einen im Arbeitsspeicher des Webservers gespeicherten Cache dar.</span><span class="sxs-lookup"><span data-stu-id="3407d-113">`IMemoryCache` represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="3407d-114">Apps, die in einer Serverfarm (mehrere Server) ausgeführt werden, sollten sicherstellen, dass Sitzungen bei Verwendung des in-Memory-Caches kurz sind.</span><span class="sxs-lookup"><span data-stu-id="3407d-114">Apps running on a server farm (multiple servers) should ensure sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="3407d-115">Mithilfe von persistenten Sitzungen wird sichergestellt, dass nachfolgende Anforderungen von einem Client an denselben Server gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="3407d-115">Sticky sessions ensure that subsequent requests from a client all go to the same server.</span></span> <span data-ttu-id="3407d-116">Azure-Web-Apps verwenden z. b. [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (arr), um alle nachfolgenden Anforderungen an denselben Server weiterzuleiten.</span><span class="sxs-lookup"><span data-stu-id="3407d-116">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all subsequent requests to the same server.</span></span>

<span data-ttu-id="3407d-117">Für nicht persistente Sitzungen in einer Webfarm ist ein [verteilter Cache](distributed.md) erforderlich, um Cache Konsistenzprobleme zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="3407d-117">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="3407d-118">Bei einigen apps kann ein verteilter Cache eine höhere horizontale Skalierung unterstützen als ein in-Memory-Cache.</span><span class="sxs-lookup"><span data-stu-id="3407d-118">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="3407d-119">Wenn Sie einen verteilten Cache verwenden, wird der Cache Speicher auf einen externen Prozess verlagert.</span><span class="sxs-lookup"><span data-stu-id="3407d-119">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="3407d-120">Der in-Memory-Cache kann beliebige Objekte speichern.</span><span class="sxs-lookup"><span data-stu-id="3407d-120">The in-memory cache can store any object.</span></span> <span data-ttu-id="3407d-121">Die verteilte Cache Schnittstelle ist auf beschränkt `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="3407d-121">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="3407d-122">Die Cache Elemente im Arbeitsspeicher und im verteilten Cache werden als Schlüssel-Wert-Paare gespeichert.</span><span class="sxs-lookup"><span data-stu-id="3407d-122">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="3407d-123">System. Runtime. Caching/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="3407d-123">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="3407d-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache>([Nuget-Paket](https://www.nuget.org/packages/System.Runtime.Caching/)) kann mit folgenden Aktionen verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="3407d-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="3407d-125">.NET Standard 2,0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="3407d-125">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="3407d-126">Alle [.net-Implementierungen](/dotnet/standard/net-standard#net-implementation-support) , die auf .NET Standard 2,0 oder höher ausgerichtet sind.</span><span class="sxs-lookup"><span data-stu-id="3407d-126">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="3407d-127">Beispielsweise ASP.net Core 2,0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="3407d-127">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="3407d-128">.NET Framework 4.5 oder höher.</span><span class="sxs-lookup"><span data-stu-id="3407d-128">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="3407d-129">[Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (in diesem Artikel beschrieben) wird empfohlen, `System.Runtime.Caching` / `MemoryCache` da Sie besser in ASP.net Core integriert ist.</span><span class="sxs-lookup"><span data-stu-id="3407d-129">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="3407d-130">Beispielsweise `IMemoryCache` funktioniert nativ mit ASP.net Core- [Abhängigkeitsinjektion](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="3407d-130">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="3407d-131">Verwenden `System.Runtime.Caching` / `MemoryCache` Sie als Kompatibilitäts Bridge, wenn Sie Code von ASP.NET 4. x auf ASP.net Core portieren.</span><span class="sxs-lookup"><span data-stu-id="3407d-131">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="3407d-132">Cache Richtlinien</span><span class="sxs-lookup"><span data-stu-id="3407d-132">Cache guidelines</span></span>

* <span data-ttu-id="3407d-133">Code sollte immer über eine Fall Back-Option zum Abrufen von Daten verfügen und **nicht** davon abhängen, dass ein zwischen gespeicherter Wert verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="3407d-133">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="3407d-134">Der Cache verwendet eine knappe Ressource, den Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="3407d-134">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="3407d-135">Beschränken Sie das Cache Wachstum:</span><span class="sxs-lookup"><span data-stu-id="3407d-135">Limit cache growth:</span></span>
  * <span data-ttu-id="3407d-136">Verwenden Sie **keine** externe Eingabe als Cache Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3407d-136">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="3407d-137">Verwenden Sie Ablauf, um das Cache Wachstum einzuschränken.</span><span class="sxs-lookup"><span data-stu-id="3407d-137">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="3407d-138">[Verwenden Sie SetSize, Size und SizeLimit, um die Cache Größe einzuschränken](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="3407d-138">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="3407d-139">Die ASP.net Core Laufzeit schränkt die Cache Größe **nicht** auf Grundlage des Arbeitsspeichers ein.</span><span class="sxs-lookup"><span data-stu-id="3407d-139">The ASP.NET Core runtime does **not** limit cache size based on memory pressure.</span></span> <span data-ttu-id="3407d-140">Der Entwickler muss die Cache Größe einschränken.</span><span class="sxs-lookup"><span data-stu-id="3407d-140">It's up to the developer to limit cache size.</span></span>

## <a name="use-imemorycache"></a><span data-ttu-id="3407d-141">Verwenden von IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="3407d-141">Use IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="3407d-142">Die Verwendung eines *Shared* Memory-Caches aus der [Abhängigkeitsinjektion](xref:fundamentals/dependency-injection) und das Aufrufen von `SetSize` , oder, `Size` `SizeLimit` um die Cache Größe einzuschränken, kann zu einem Fehler der APP führen.</span><span class="sxs-lookup"><span data-stu-id="3407d-142">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="3407d-143">Wenn eine Größenbeschränkung für einen Cache festgelegt wird, müssen alle Einträge beim Hinzufügen eine Größe angeben.</span><span class="sxs-lookup"><span data-stu-id="3407d-143">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="3407d-144">Dies kann zu Problemen führen, da Entwickler möglicherweise nicht die vollständige Kontrolle darüber haben, was den freigegebenen Cache verwendet.</span><span class="sxs-lookup"><span data-stu-id="3407d-144">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="3407d-145">Beispielsweise wird von Entity Framework Core der freigegebene Cache verwendet, und es wird keine Größe angegeben.</span><span class="sxs-lookup"><span data-stu-id="3407d-145">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="3407d-146">Wenn eine APP eine Cache Größenbeschränkung festlegt und EF Core verwendet, löst die APP eine aus `InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="3407d-146">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="3407d-147">Wenn Sie `SetSize` , `Size` oder verwenden, `SizeLimit` um den Cache einzuschränken, erstellen Sie einen Cache Singleton zum Zwischenspeichern.</span><span class="sxs-lookup"><span data-stu-id="3407d-147">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="3407d-148">Weitere Informationen und ein Beispiel finden Sie unter [Verwenden von "setSize", "size" und "SizeLimit", um die Cache Größe einzuschränken](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="3407d-148">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>
> <span data-ttu-id="3407d-149">Ein frei gegebener Cache wird von anderen Frameworks oder Bibliotheken gemeinsam genutzt.</span><span class="sxs-lookup"><span data-stu-id="3407d-149">A shared cache is one shared by other frameworks or libraries.</span></span> <span data-ttu-id="3407d-150">Beispielsweise wird von EF Core der freigegebene Cache verwendet, und es wird keine Größe angegeben.</span><span class="sxs-lookup"><span data-stu-id="3407d-150">For example, EF Core uses the shared cache and does not specify a size.</span></span> 

<span data-ttu-id="3407d-151">In-Memory-Caching ist ein *Dienst* , auf den von einer App mithilfe von [Abhängigkeitsinjektion](xref:fundamentals/dependency-injection)verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="3407d-151">In-memory caching is a *service* that's referenced from an app using [Dependency Injection](xref:fundamentals/dependency-injection).</span></span> <span data-ttu-id="3407d-152">Fordern Sie die `IMemoryCache` Instanz im Konstruktor an:</span><span class="sxs-lookup"><span data-stu-id="3407d-152">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="3407d-153">Im folgenden Code wird [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) verwendet, um zu überprüfen, ob sich eine Uhrzeit im Cache befindet.</span><span class="sxs-lookup"><span data-stu-id="3407d-153">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="3407d-154">Wenn eine Zeit nicht zwischengespeichert wird, wird ein neuer Eintrag erstellt und mit [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_)dem Cache hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="3407d-154">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span> <span data-ttu-id="3407d-155">Die- `CacheKeys` Klasse ist Teil des Download Beispiels.</span><span class="sxs-lookup"><span data-stu-id="3407d-155">The `CacheKeys` class is part of the download sample.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/CacheKeys.cs)]

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="3407d-156">Die aktuelle Uhrzeit und die zwischengespeicherte Zeit werden angezeigt:</span><span class="sxs-lookup"><span data-stu-id="3407d-156">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/3.0sample/WebCacheSample/Views/Home/Cache.cshtml)]

<span data-ttu-id="3407d-157">Der zwischengespeicherte `DateTime` Wert verbleibt im Cache, während innerhalb des Timeout Zeitraums Anforderungen vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="3407d-157">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span>

<span data-ttu-id="3407d-158">Der folgende Code verwendet [getorcreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) und [getorkreateasync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) zum Zwischenspeichern von Daten.</span><span class="sxs-lookup"><span data-stu-id="3407d-158">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="3407d-159">Mit dem folgenden Code wird [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) aufgerufen, um die zwischengespeicherte Zeit abzurufen:</span><span class="sxs-lookup"><span data-stu-id="3407d-159">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="3407d-160">Mit dem folgenden Code wird ein zwischengespeichertes Element mit dem absoluten Ablauf abgerufen oder erstellt:</span><span class="sxs-lookup"><span data-stu-id="3407d-160">The following code gets or creates a cached item with absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet99)]

<span data-ttu-id="3407d-161">Ein zwischengespeichertes Element mit einer gleitenden Ablaufzeit besteht lediglich aus dem Risiko, veraltet zu werden.</span><span class="sxs-lookup"><span data-stu-id="3407d-161">A cached item set with a sliding expiration only is at risk of becoming stale.</span></span> <span data-ttu-id="3407d-162">Wenn der Zugriff häufiger erfolgt als das gleitende Ablauf Intervall, läuft das Element nie ab.</span><span class="sxs-lookup"><span data-stu-id="3407d-162">If it's accessed more frequently than the sliding expiration interval, the item will never expire.</span></span> <span data-ttu-id="3407d-163">Kombinieren Sie einen gleitenden Ablauf mit einem absoluten Ablauf, um sicherzustellen, dass das Element abläuft, sobald die absolute Ablaufzeit abgelaufen ist.</span><span class="sxs-lookup"><span data-stu-id="3407d-163">Combine a sliding expiration with an absolute expiration to guarantee that the item expires once its absolute expiration time passes.</span></span> <span data-ttu-id="3407d-164">Der absolute Ablauf legt eine obere Grenze fest, die angibt, wie lange das Element zwischengespeichert werden kann, während das Element noch früher ablaufen kann, wenn es innerhalb des gleitenden Ablauf Intervalls nicht angefordert wird.</span><span class="sxs-lookup"><span data-stu-id="3407d-164">The absolute expiration sets an upper bound to how long the item can be cached while still allowing the item to expire earlier if it isn't requested within the sliding expiration interval.</span></span> <span data-ttu-id="3407d-165">Wenn absolute und gleitender Ablauf angegeben werden, werden die Abläufe logisch ORed.</span><span class="sxs-lookup"><span data-stu-id="3407d-165">When both absolute and sliding expiration are specified, the expirations are logically ORed.</span></span> <span data-ttu-id="3407d-166">Wenn entweder das gleitende Ablauf Intervall *oder* die absolute Ablaufzeit abgelaufen ist, wird das Element aus dem Cache entfernt.</span><span class="sxs-lookup"><span data-stu-id="3407d-166">If either the sliding expiration interval *or* the absolute expiration time pass, the item is evicted from the cache.</span></span>

<span data-ttu-id="3407d-167">Mit dem folgenden Code wird ein zwischengespeichertes Element mit gleitender *und* absolutem Ablauf abgerufen oder erstellt:</span><span class="sxs-lookup"><span data-stu-id="3407d-167">The following code gets or creates a cached item with both sliding *and* absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet9)]

<span data-ttu-id="3407d-168">Der vorangehende Code stellt sicher, dass die Daten nicht länger als die absolute Zeit zwischengespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="3407d-168">The preceding code guarantees the data will not be cached longer than the absolute time.</span></span>

<span data-ttu-id="3407d-169"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> und <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> sind Erweiterungs Methoden in der- <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> Klasse.</span><span class="sxs-lookup"><span data-stu-id="3407d-169"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> are extension methods in the <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> class.</span></span> <span data-ttu-id="3407d-170">Diese Methoden erweitern die Funktionalität von <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="3407d-170">These methods extend the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="3407d-171">Memorycacheentryoptions</span><span class="sxs-lookup"><span data-stu-id="3407d-171">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="3407d-172">Im folgenden Beispiel:</span><span class="sxs-lookup"><span data-stu-id="3407d-172">The following sample:</span></span>

* <span data-ttu-id="3407d-173">Legt eine gleitende Ablaufzeit fest.</span><span class="sxs-lookup"><span data-stu-id="3407d-173">Sets a sliding expiration time.</span></span> <span data-ttu-id="3407d-174">Anforderungen, die auf dieses zwischengespeicherte Element zugreifen, setzen die gleitende Ablaufzeit zurück.</span><span class="sxs-lookup"><span data-stu-id="3407d-174">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="3407d-175">Legt die Cache Priorität auf [CacheItemPriority. neverremove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove)fest.</span><span class="sxs-lookup"><span data-stu-id="3407d-175">Sets the cache priority to [CacheItemPriority.NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span></span>
* <span data-ttu-id="3407d-176">Legt einen [postevictiondelegaten](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) fest, der nach dem Entfernen des Eintrags aus dem Cache aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="3407d-176">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="3407d-177">Der Rückruf wird in einem anderen Thread als dem Code ausgeführt, der das Element aus dem Cache entfernt.</span><span class="sxs-lookup"><span data-stu-id="3407d-177">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="3407d-178">Verwenden von "setSize", "size" und "SizeLimit" zum Begrenzen der Cache Größe</span><span class="sxs-lookup"><span data-stu-id="3407d-178">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="3407d-179">Eine `MemoryCache` -Instanz kann optional eine Größenbeschränkung angeben und erzwingen.</span><span class="sxs-lookup"><span data-stu-id="3407d-179">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="3407d-180">Das Cache Größenlimit weist keine definierte Maßeinheit auf, da der Cache keinen Mechanismus zum Messen der Größe der Einträge aufweist.</span><span class="sxs-lookup"><span data-stu-id="3407d-180">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="3407d-181">Wenn die Cache Größenbeschränkung festgelegt ist, müssen alle Einträge die Größe angeben.</span><span class="sxs-lookup"><span data-stu-id="3407d-181">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="3407d-182">Die ASP.net Core Laufzeit schränkt die Cache Größe nicht auf Grundlage des Arbeitsspeichers ein.</span><span class="sxs-lookup"><span data-stu-id="3407d-182">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="3407d-183">Der Entwickler muss die Cache Größe einschränken.</span><span class="sxs-lookup"><span data-stu-id="3407d-183">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="3407d-184">Die angegebene Größe befindet sich in Einheiten, die vom Entwickler ausgewählt werden.</span><span class="sxs-lookup"><span data-stu-id="3407d-184">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="3407d-185">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="3407d-185">For example:</span></span>

* <span data-ttu-id="3407d-186">Wenn die Web-App primär Zeichen folgen zwischenspeichert, könnte jede Cache Eintrags Größe die Zeichen folgen Länge aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3407d-186">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="3407d-187">Die APP kann die Größe aller Einträge als 1 angeben, und die Größenbeschränkung ist die Anzahl der Einträge.</span><span class="sxs-lookup"><span data-stu-id="3407d-187">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="3407d-188">Wenn <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> nicht festgelegt ist, wächst der Cache ohne Bindung.</span><span class="sxs-lookup"><span data-stu-id="3407d-188">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> isn't set, the cache grows without bound.</span></span> <span data-ttu-id="3407d-189">Die ASP.net Core-Laufzeit schneidet den Cache nicht ab, wenn der Systemspeicher gering ist.</span><span class="sxs-lookup"><span data-stu-id="3407d-189">The ASP.NET Core runtime doesn't trim the cache when system memory is low.</span></span> <span data-ttu-id="3407d-190">Apps müssen für Folgendes entworfen werden:</span><span class="sxs-lookup"><span data-stu-id="3407d-190">Apps must be architected to:</span></span>

* <span data-ttu-id="3407d-191">Beschränken Sie das Cache Wachstum.</span><span class="sxs-lookup"><span data-stu-id="3407d-191">Limit cache growth.</span></span>
* <span data-ttu-id="3407d-192"><xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*>Oder, <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> Wenn der verfügbare Arbeitsspeicher begrenzt ist:</span><span class="sxs-lookup"><span data-stu-id="3407d-192">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="3407d-193">Mit dem folgenden Code wird eine nicht für die <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> [Abhängigkeitsinjektion](xref:fundamentals/dependency-injection)verfügbare, nicht aufgelegte Größe erstellt</span><span class="sxs-lookup"><span data-stu-id="3407d-193">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="3407d-194">`SizeLimit`verfügt über keine Einheiten.</span><span class="sxs-lookup"><span data-stu-id="3407d-194">`SizeLimit` does not have units.</span></span> <span data-ttu-id="3407d-195">Bei zwischengespeicherten Einträgen muss die Größe in allen Einheiten angegeben werden, die Sie am besten als geeignet eingrenzen, wenn die Cache Größe festgelegt wurde</span><span class="sxs-lookup"><span data-stu-id="3407d-195">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="3407d-196">Alle Benutzer einer Cache Instanz sollten das gleiche Einheitensystem verwenden.</span><span class="sxs-lookup"><span data-stu-id="3407d-196">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="3407d-197">Ein Eintrag wird nicht zwischengespeichert, wenn die Summe der zwischengespeicherten Eintrags Größen den von angegebenen Wert überschreitet `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="3407d-197">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="3407d-198">Wenn keine Cache Größenbeschränkung festgelegt ist, wird die für den Eintrag festgelegte Cache Größe ignoriert.</span><span class="sxs-lookup"><span data-stu-id="3407d-198">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="3407d-199">Der folgende Code wird `MyMemoryCache` mit dem Container für die [Abhängigkeitsinjektion](xref:fundamentals/dependency-injection) registriert.</span><span class="sxs-lookup"><span data-stu-id="3407d-199">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Startup.cs?name=snippet)]

<span data-ttu-id="3407d-200">`MyMemoryCache`wird als unabhängiger Speicher Cache für Komponenten erstellt, die diesen Größen eingeschränkten Cache beachten, und wissen, wie die Größe des Cache Eintrags entsprechend festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="3407d-200">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="3407d-201">Der folgende Code verwendet `MyMemoryCache` :</span><span class="sxs-lookup"><span data-stu-id="3407d-201">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet)]

<span data-ttu-id="3407d-202">Die Größe des Cache Eintrags kann von <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> oder den Erweiterungs Methoden festgelegt werden <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> :</span><span class="sxs-lookup"><span data-stu-id="3407d-202">The size of the cache entry can be set by <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> or the <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> extension methods:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="3407d-203">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="3407d-203">MemoryCache.Compact</span></span>

<span data-ttu-id="3407d-204">`MemoryCache.Compact`versucht, den angegebenen Prozentsatz des Caches in der folgenden Reihenfolge zu entfernen:</span><span class="sxs-lookup"><span data-stu-id="3407d-204">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="3407d-205">Alle abgelaufenen Elemente.</span><span class="sxs-lookup"><span data-stu-id="3407d-205">All expired items.</span></span>
* <span data-ttu-id="3407d-206">Elemente nach Priorität.</span><span class="sxs-lookup"><span data-stu-id="3407d-206">Items by priority.</span></span> <span data-ttu-id="3407d-207">Elemente der niedrigsten Priorität werden zuerst entfernt.</span><span class="sxs-lookup"><span data-stu-id="3407d-207">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="3407d-208">Zuletzt verwendete Objekte.</span><span class="sxs-lookup"><span data-stu-id="3407d-208">Least recently used objects.</span></span>
* <span data-ttu-id="3407d-209">Elemente mit dem frühesten absoluten Ablauf.</span><span class="sxs-lookup"><span data-stu-id="3407d-209">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="3407d-210">Elemente mit der frühesten gleitenden Ablaufzeit.</span><span class="sxs-lookup"><span data-stu-id="3407d-210">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="3407d-211">Fixierte Elemente mit Priorität <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> werden nie entfernt.</span><span class="sxs-lookup"><span data-stu-id="3407d-211">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span> <span data-ttu-id="3407d-212">Der folgende Code entfernt ein Cache Element und ruft auf `Compact` :</span><span class="sxs-lookup"><span data-stu-id="3407d-212">The following code removes a cache item and calls `Compact`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="3407d-213">Weitere Informationen finden Sie [unter Compact Source auf GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) .</span><span class="sxs-lookup"><span data-stu-id="3407d-213">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="3407d-214">Cache Abhängigkeiten</span><span class="sxs-lookup"><span data-stu-id="3407d-214">Cache dependencies</span></span>

<span data-ttu-id="3407d-215">Im folgenden Beispiel wird gezeigt, wie ein Cache Eintrag abläuft, wenn ein abhängiger Eintrag abläuft.</span><span class="sxs-lookup"><span data-stu-id="3407d-215">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="3407d-216"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>Dem zwischengespeicherten Element wird ein hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="3407d-216">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="3407d-217">Wenn `Cancel` für aufgerufen wird `CancellationTokenSource` , werden beide Cache Einträge entfernt.</span><span class="sxs-lookup"><span data-stu-id="3407d-217">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="3407d-218">Durch <xref:System.Threading.CancellationTokenSource> die Verwendung von können mehrere Cache Einträge als Gruppe entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="3407d-218">Using a <xref:System.Threading.CancellationTokenSource> allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="3407d-219">Mit dem `using` Muster im obigen Code erben Cache Einträge, die innerhalb des- `using` Blocks erstellt werden, Trigger und Ablauf Einstellungen.</span><span class="sxs-lookup"><span data-stu-id="3407d-219">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="3407d-220">Zusätzliche Hinweise</span><span class="sxs-lookup"><span data-stu-id="3407d-220">Additional notes</span></span>

* <span data-ttu-id="3407d-221">Das Ablaufdatum wird im Hintergrund nicht angezeigt.</span><span class="sxs-lookup"><span data-stu-id="3407d-221">Expiration doesn't happen in the background.</span></span> <span data-ttu-id="3407d-222">Es gibt keinen Timer, der den Cache aktiv nach abgelaufenen Elementen scannt.</span><span class="sxs-lookup"><span data-stu-id="3407d-222">There is no timer that actively scans the cache for expired items.</span></span> <span data-ttu-id="3407d-223">Jede Aktivität im Cache ( `Get` , `Set` , `Remove` ) kann eine Hintergrund Überprüfung für abgelaufene Elemente auslöst.</span><span class="sxs-lookup"><span data-stu-id="3407d-223">Any activity on the cache (`Get`, `Set`, `Remove`) can trigger a background scan for expired items.</span></span> <span data-ttu-id="3407d-224">Ein Timer `CancellationTokenSource` <xref:System.Threading.CancellationTokenSource.CancelAfter*> für () entfernt ebenfalls den Eintrag und löst eine Überprüfung abgelaufener Elemente aus.</span><span class="sxs-lookup"><span data-stu-id="3407d-224">A timer on the `CancellationTokenSource` (<xref:System.Threading.CancellationTokenSource.CancelAfter*>) also removes the entry and trigger a scan for expired items.</span></span> <span data-ttu-id="3407d-225">Im folgenden Beispiel wird [CancellationTokenSource (TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) für das registrierte Token verwendet.</span><span class="sxs-lookup"><span data-stu-id="3407d-225">The following example uses [CancellationTokenSource(TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) for the registered token.</span></span> <span data-ttu-id="3407d-226">Wenn dieses Token ausgelöst wird, wird der Eintrag sofort entfernt, und die Entfernungs Rückrufe werden ausgelöst:</span><span class="sxs-lookup"><span data-stu-id="3407d-226">When this token fires it removes the entry immediately and fires the eviction callbacks:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ae)]

* <span data-ttu-id="3407d-227">Bei Verwendung eines Rückrufs zum erneuten Auffüllen eines Cache Elements:</span><span class="sxs-lookup"><span data-stu-id="3407d-227">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="3407d-228">Mehrere Anforderungen können den zwischengespeicherten Schlüsselwert leer finden, da der Rückruf noch nicht abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="3407d-228">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="3407d-229">Dies kann dazu führen, dass mehrere Threads das zwischengespeicherte Element neu auffüllen.</span><span class="sxs-lookup"><span data-stu-id="3407d-229">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="3407d-230">Wenn ein Cache Eintrag verwendet wird, um einen anderen zu erstellen, kopiert das untergeordnete Element die Ablauf Token und zeitbasierten Ablauf Einstellungen des übergeordneten Eintrags.</span><span class="sxs-lookup"><span data-stu-id="3407d-230">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="3407d-231">Das untergeordnete Element ist nicht abgelaufen, wenn der übergeordnete Eintrag manuell entfernt oder aktualisiert wird.</span><span class="sxs-lookup"><span data-stu-id="3407d-231">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="3407d-232">Verwenden <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> Sie, um die Rückrufe festzulegen, die ausgelöst werden, nachdem der Cache Eintrag aus dem Cache entfernt wurde.</span><span class="sxs-lookup"><span data-stu-id="3407d-232">Use <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>
* <span data-ttu-id="3407d-233">Für die meisten apps `IMemoryCache` ist aktiviert.</span><span class="sxs-lookup"><span data-stu-id="3407d-233">For most apps, `IMemoryCache` is enabled.</span></span> <span data-ttu-id="3407d-234">Wenn z. b `AddMvc` `AddControllersWithViews` .,,, `AddRazorPages` `AddMvcCore().AddRazorViewEngine` und viele andere `Add{Service}` Methoden in `ConfigureServices` aufgerufen werden, wird aktiviert `IMemoryCache` .</span><span class="sxs-lookup"><span data-stu-id="3407d-234">For example, calling `AddMvc`, `AddControllersWithViews`, `AddRazorPages`, `AddMvcCore().AddRazorViewEngine`, and many other `Add{Service}` methods in `ConfigureServices`, enables `IMemoryCache`.</span></span> <span data-ttu-id="3407d-235">Für apps, die keine der vorangehenden Methoden aufrufen `Add{Service}` , muss möglicherweise in aufgerufen werden <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> `ConfigureServices` .</span><span class="sxs-lookup"><span data-stu-id="3407d-235">For apps that are not calling one of the preceding `Add{Service}` methods, it may be necessary to call <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> in `ConfigureServices`.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="3407d-236">Cache Update im Hintergrund</span><span class="sxs-lookup"><span data-stu-id="3407d-236">Background cache update</span></span>

<span data-ttu-id="3407d-237">Verwenden Sie einen [Hintergrunddienst](xref:fundamentals/host/hosted-services) wie <xref:Microsoft.Extensions.Hosting.IHostedService> zum Aktualisieren des Caches.</span><span class="sxs-lookup"><span data-stu-id="3407d-237">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="3407d-238">Der Hintergrunddienst kann die Einträge neu berechnen und Sie dann nur dann dem Cache zuweisen, wenn Sie bereit sind.</span><span class="sxs-lookup"><span data-stu-id="3407d-238">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="3407d-239">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="3407d-239">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end

::: moniker range="< aspnetcore-3.0"

<!-- This is the 2.1 version -->
<span data-ttu-id="3407d-240">Von [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo)und [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="3407d-240">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="3407d-241">[Anzeigen oder Herunterladen von Beispielcode](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([Vorgehensweise zum Herunterladen](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="3407d-241">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="3407d-242">Grundlagen zum Caching</span><span class="sxs-lookup"><span data-stu-id="3407d-242">Caching basics</span></span>

<span data-ttu-id="3407d-243">Die Zwischenspeicherung kann die Leistung und Skalierbarkeit einer APP erheblich verbessern, indem die zum Generieren von Inhalten erforderliche Arbeit reduziert wird.</span><span class="sxs-lookup"><span data-stu-id="3407d-243">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="3407d-244">Das Caching funktioniert am besten mit Daten, die sich nur selten ändern.</span><span class="sxs-lookup"><span data-stu-id="3407d-244">Caching works best with data that changes infrequently.</span></span> <span data-ttu-id="3407d-245">Durch das Zwischenspeichern wird eine Kopie der Daten erstellt, die viel schneller als aus der ursprünglichen Quelle zurückgegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="3407d-245">Caching makes a copy of data that can be returned much faster than from the original source.</span></span> <span data-ttu-id="3407d-246">Code sollte so geschrieben und getestet werden, dass er **nie** von zwischengespeicherten Daten abhängt.</span><span class="sxs-lookup"><span data-stu-id="3407d-246">Code should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="3407d-247">ASP.net Core unterstützt mehrere verschiedene Caches.</span><span class="sxs-lookup"><span data-stu-id="3407d-247">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="3407d-248">Der einfachste Cache basiert auf dem [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), der einen Cache darstellt, der im Arbeitsspeicher des Webservers gespeichert ist.</span><span class="sxs-lookup"><span data-stu-id="3407d-248">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), which represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="3407d-249">Apps, die in einer Serverfarm (mehrere Server) ausgeführt werden, sollten sicherstellen, dass Sitzungen bei Verwendung des in-Memory-Caches kurz sind.</span><span class="sxs-lookup"><span data-stu-id="3407d-249">Apps that run on a server farm (multiple servers) should ensure that sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="3407d-250">Mithilfe von persistenten Sitzungen wird sichergestellt, dass spätere Anforderungen von einem Client an denselben Server gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="3407d-250">Sticky sessions ensure that later requests from a client all go to the same server.</span></span> <span data-ttu-id="3407d-251">Azure-Web-Apps verwenden z. b. [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (arr), um alle Anforderungen von einem Benutzer-Agent an denselben Server weiterzuleiten.</span><span class="sxs-lookup"><span data-stu-id="3407d-251">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all requests from a user agent to the same server.</span></span>

<span data-ttu-id="3407d-252">Für nicht persistente Sitzungen in einer Webfarm ist ein [verteilter Cache](distributed.md) erforderlich, um Cache Konsistenzprobleme zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="3407d-252">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="3407d-253">Bei einigen apps kann ein verteilter Cache eine höhere horizontale Skalierung unterstützen als ein in-Memory-Cache.</span><span class="sxs-lookup"><span data-stu-id="3407d-253">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="3407d-254">Wenn Sie einen verteilten Cache verwenden, wird der Cache Speicher auf einen externen Prozess verlagert.</span><span class="sxs-lookup"><span data-stu-id="3407d-254">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="3407d-255">Der in-Memory-Cache kann beliebige Objekte speichern.</span><span class="sxs-lookup"><span data-stu-id="3407d-255">The in-memory cache can store any object.</span></span> <span data-ttu-id="3407d-256">Die verteilte Cache Schnittstelle ist auf beschränkt `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="3407d-256">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="3407d-257">Die Cache Elemente im Arbeitsspeicher und im verteilten Cache werden als Schlüssel-Wert-Paare gespeichert.</span><span class="sxs-lookup"><span data-stu-id="3407d-257">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="3407d-258">System. Runtime. Caching/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="3407d-258">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="3407d-259"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache>([Nuget-Paket](https://www.nuget.org/packages/System.Runtime.Caching/)) kann mit folgenden Aktionen verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="3407d-259"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="3407d-260">.NET Standard 2,0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="3407d-260">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="3407d-261">Alle [.net-Implementierungen](/dotnet/standard/net-standard#net-implementation-support) , die auf .NET Standard 2,0 oder höher ausgerichtet sind.</span><span class="sxs-lookup"><span data-stu-id="3407d-261">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="3407d-262">Beispielsweise ASP.net Core 2,0 oder höher.</span><span class="sxs-lookup"><span data-stu-id="3407d-262">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="3407d-263">.NET Framework 4.5 oder höher.</span><span class="sxs-lookup"><span data-stu-id="3407d-263">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="3407d-264">[Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (in diesem Artikel beschrieben) wird empfohlen, `System.Runtime.Caching` / `MemoryCache` da Sie besser in ASP.net Core integriert ist.</span><span class="sxs-lookup"><span data-stu-id="3407d-264">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="3407d-265">Beispielsweise `IMemoryCache` funktioniert nativ mit ASP.net Core- [Abhängigkeitsinjektion](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="3407d-265">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="3407d-266">Verwenden `System.Runtime.Caching` / `MemoryCache` Sie als Kompatibilitäts Bridge, wenn Sie Code von ASP.NET 4. x auf ASP.net Core portieren.</span><span class="sxs-lookup"><span data-stu-id="3407d-266">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="3407d-267">Cache Richtlinien</span><span class="sxs-lookup"><span data-stu-id="3407d-267">Cache guidelines</span></span>

* <span data-ttu-id="3407d-268">Code sollte immer über eine Fall Back-Option zum Abrufen von Daten verfügen und **nicht** davon abhängen, dass ein zwischen gespeicherter Wert verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="3407d-268">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="3407d-269">Der Cache verwendet eine knappe Ressource, den Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="3407d-269">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="3407d-270">Beschränken Sie das Cache Wachstum:</span><span class="sxs-lookup"><span data-stu-id="3407d-270">Limit cache growth:</span></span>
  * <span data-ttu-id="3407d-271">Verwenden Sie **keine** externe Eingabe als Cache Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3407d-271">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="3407d-272">Verwenden Sie Ablauf, um das Cache Wachstum einzuschränken.</span><span class="sxs-lookup"><span data-stu-id="3407d-272">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="3407d-273">[Verwenden Sie SetSize, Size und SizeLimit, um die Cache Größe einzuschränken](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="3407d-273">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="3407d-274">Die ASP.net Core Laufzeit schränkt die Cache Größe nicht auf Grundlage des Arbeitsspeichers ein.</span><span class="sxs-lookup"><span data-stu-id="3407d-274">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="3407d-275">Der Entwickler muss die Cache Größe einschränken.</span><span class="sxs-lookup"><span data-stu-id="3407d-275">It's up to the developer to limit cache size.</span></span>

## <a name="using-imemorycache"></a><span data-ttu-id="3407d-276">Verwenden von IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="3407d-276">Using IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="3407d-277">Die Verwendung eines *Shared* Memory-Caches aus der [Abhängigkeitsinjektion](xref:fundamentals/dependency-injection) und das Aufrufen von `SetSize` , oder, `Size` `SizeLimit` um die Cache Größe einzuschränken, kann zu einem Fehler der APP führen.</span><span class="sxs-lookup"><span data-stu-id="3407d-277">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="3407d-278">Wenn eine Größenbeschränkung für einen Cache festgelegt wird, müssen alle Einträge beim Hinzufügen eine Größe angeben.</span><span class="sxs-lookup"><span data-stu-id="3407d-278">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="3407d-279">Dies kann zu Problemen führen, da Entwickler möglicherweise nicht die vollständige Kontrolle darüber haben, was den freigegebenen Cache verwendet.</span><span class="sxs-lookup"><span data-stu-id="3407d-279">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="3407d-280">Beispielsweise wird von Entity Framework Core der freigegebene Cache verwendet, und es wird keine Größe angegeben.</span><span class="sxs-lookup"><span data-stu-id="3407d-280">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="3407d-281">Wenn eine APP eine Cache Größenbeschränkung festlegt und EF Core verwendet, löst die APP eine aus `InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="3407d-281">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="3407d-282">Wenn Sie `SetSize` , `Size` oder verwenden, `SizeLimit` um den Cache einzuschränken, erstellen Sie einen Cache Singleton zum Zwischenspeichern.</span><span class="sxs-lookup"><span data-stu-id="3407d-282">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="3407d-283">Weitere Informationen und ein Beispiel finden Sie unter [Verwenden von "setSize", "size" und "SizeLimit", um die Cache Größe einzuschränken](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="3407d-283">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>

<span data-ttu-id="3407d-284">In-Memory-Caching ist ein *Dienst* , auf den von ihrer App mithilfe von [Abhängigkeitsinjektion](../../fundamentals/dependency-injection.md)verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="3407d-284">In-memory caching is a *service* that's referenced from your app using [Dependency Injection](../../fundamentals/dependency-injection.md).</span></span> <span data-ttu-id="3407d-285">Anrufen `AddMemoryCache` in `ConfigureServices` :</span><span class="sxs-lookup"><span data-stu-id="3407d-285">Call `AddMemoryCache` in `ConfigureServices`:</span></span>

[!code-csharp[](memory/sample/WebCache/Startup.cs?highlight=9)]

<span data-ttu-id="3407d-286">Fordern Sie die `IMemoryCache` Instanz im Konstruktor an:</span><span class="sxs-lookup"><span data-stu-id="3407d-286">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="3407d-287">`IMemoryCache`erfordert das nuget-Paket [Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), das im [Metapaket Microsoft. aspnetcore. app](xref:fundamentals/metapackage-app)verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="3407d-287">`IMemoryCache` requires NuGet package [Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), which is available in the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app).</span></span>

<span data-ttu-id="3407d-288">Im folgenden Code wird [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) verwendet, um zu überprüfen, ob sich eine Uhrzeit im Cache befindet.</span><span class="sxs-lookup"><span data-stu-id="3407d-288">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="3407d-289">Wenn eine Zeit nicht zwischengespeichert wird, wird ein neuer Eintrag erstellt und mit [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_)dem Cache hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="3407d-289">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span>

[!code-csharp[](memory/sample/WebCache/CacheKeys.cs)]

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="3407d-290">Die aktuelle Uhrzeit und die zwischengespeicherte Zeit werden angezeigt:</span><span class="sxs-lookup"><span data-stu-id="3407d-290">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/sample/WebCache/Views/Home/Cache.cshtml)]

<span data-ttu-id="3407d-291">Der zwischengespeicherte `DateTime` Wert verbleibt im Cache, während innerhalb des Timeout Zeitraums Anforderungen vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="3407d-291">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span> <span data-ttu-id="3407d-292">Die folgende Abbildung zeigt die aktuelle Uhrzeit und eine ältere Zeit, die aus dem Cache abgerufen wurde:</span><span class="sxs-lookup"><span data-stu-id="3407d-292">The following image shows the current time and an older time retrieved from the cache:</span></span>

![Index Sicht mit zwei unterschiedlichen Uhrzeiten](memory/_static/time.png)

<span data-ttu-id="3407d-294">Der folgende Code verwendet [getorcreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) und [getorkreateasync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) zum Zwischenspeichern von Daten.</span><span class="sxs-lookup"><span data-stu-id="3407d-294">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="3407d-295">Mit dem folgenden Code wird [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) aufgerufen, um die zwischengespeicherte Zeit abzurufen:</span><span class="sxs-lookup"><span data-stu-id="3407d-295">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="3407d-296"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> und [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) sind Erweiterungs Methoden, die Teil der [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) -Klasse sind und die Funktionen von erweitern <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="3407d-296"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*> , <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) are extension methods part of the [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) class that extends the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span> <span data-ttu-id="3407d-297">Eine Beschreibung anderer Cache Methoden finden Sie unter [IMemoryCache-Methoden](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) und [CacheExtensions-Methoden](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) .</span><span class="sxs-lookup"><span data-stu-id="3407d-297">See [IMemoryCache methods](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) and [CacheExtensions methods](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) for a description of other cache methods.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="3407d-298">Memorycacheentryoptions</span><span class="sxs-lookup"><span data-stu-id="3407d-298">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="3407d-299">Im folgenden Beispiel:</span><span class="sxs-lookup"><span data-stu-id="3407d-299">The following sample:</span></span>

* <span data-ttu-id="3407d-300">Legt eine gleitende Ablaufzeit fest.</span><span class="sxs-lookup"><span data-stu-id="3407d-300">Sets a sliding expiration time.</span></span> <span data-ttu-id="3407d-301">Anforderungen, die auf dieses zwischengespeicherte Element zugreifen, setzen die gleitende Ablaufzeit zurück.</span><span class="sxs-lookup"><span data-stu-id="3407d-301">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="3407d-302">Legt die Cache Priorität auf fest `CacheItemPriority.NeverRemove` .</span><span class="sxs-lookup"><span data-stu-id="3407d-302">Sets the cache priority to `CacheItemPriority.NeverRemove`.</span></span>
* <span data-ttu-id="3407d-303">Legt einen [postevictiondelegaten](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) fest, der nach dem Entfernen des Eintrags aus dem Cache aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="3407d-303">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="3407d-304">Der Rückruf wird in einem anderen Thread als dem Code ausgeführt, der das Element aus dem Cache entfernt.</span><span class="sxs-lookup"><span data-stu-id="3407d-304">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="3407d-305">Verwenden von "setSize", "size" und "SizeLimit" zum Begrenzen der Cache Größe</span><span class="sxs-lookup"><span data-stu-id="3407d-305">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="3407d-306">Eine `MemoryCache` -Instanz kann optional eine Größenbeschränkung angeben und erzwingen.</span><span class="sxs-lookup"><span data-stu-id="3407d-306">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="3407d-307">Das Cache Größenlimit weist keine definierte Maßeinheit auf, da der Cache keinen Mechanismus zum Messen der Größe der Einträge aufweist.</span><span class="sxs-lookup"><span data-stu-id="3407d-307">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="3407d-308">Wenn die Cache Größenbeschränkung festgelegt ist, müssen alle Einträge die Größe angeben.</span><span class="sxs-lookup"><span data-stu-id="3407d-308">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="3407d-309">Die ASP.net Core Laufzeit schränkt die Cache Größe nicht auf Grundlage des Arbeitsspeichers ein.</span><span class="sxs-lookup"><span data-stu-id="3407d-309">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="3407d-310">Der Entwickler muss die Cache Größe einschränken.</span><span class="sxs-lookup"><span data-stu-id="3407d-310">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="3407d-311">Die angegebene Größe befindet sich in Einheiten, die vom Entwickler ausgewählt werden.</span><span class="sxs-lookup"><span data-stu-id="3407d-311">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="3407d-312">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="3407d-312">For example:</span></span>

* <span data-ttu-id="3407d-313">Wenn die Web-App primär Zeichen folgen zwischenspeichert, könnte jede Cache Eintrags Größe die Zeichen folgen Länge aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3407d-313">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="3407d-314">Die APP kann die Größe aller Einträge als 1 angeben, und die Größenbeschränkung ist die Anzahl der Einträge.</span><span class="sxs-lookup"><span data-stu-id="3407d-314">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="3407d-315">Wenn <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> nicht festgelegt ist, wächst der Cache ohne Bindung.</span><span class="sxs-lookup"><span data-stu-id="3407d-315">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> is not set, the cache grows without bound.</span></span> <span data-ttu-id="3407d-316">Die ASP.net Core Laufzeit schneidet den Cache nicht ab, wenn der Systemspeicher gering ist.</span><span class="sxs-lookup"><span data-stu-id="3407d-316">The ASP.NET Core runtime does not trim the cache when system memory is low.</span></span> <span data-ttu-id="3407d-317">Apps sind für Folgendes ausgelegt:</span><span class="sxs-lookup"><span data-stu-id="3407d-317">Apps much be architected to:</span></span>

* <span data-ttu-id="3407d-318">Beschränken Sie das Cache Wachstum.</span><span class="sxs-lookup"><span data-stu-id="3407d-318">Limit cache growth.</span></span>
* <span data-ttu-id="3407d-319"><xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*>Oder, <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> Wenn der verfügbare Arbeitsspeicher begrenzt ist:</span><span class="sxs-lookup"><span data-stu-id="3407d-319">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="3407d-320">Mit dem folgenden Code wird eine nicht für die <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> [Abhängigkeitsinjektion](xref:fundamentals/dependency-injection)verfügbare, nicht aufgelegte Größe erstellt</span><span class="sxs-lookup"><span data-stu-id="3407d-320">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="3407d-321">`SizeLimit`verfügt über keine Einheiten.</span><span class="sxs-lookup"><span data-stu-id="3407d-321">`SizeLimit` does not have units.</span></span> <span data-ttu-id="3407d-322">Bei zwischengespeicherten Einträgen muss die Größe in allen Einheiten angegeben werden, die Sie am besten als geeignet eingrenzen, wenn die Cache Größe festgelegt wurde</span><span class="sxs-lookup"><span data-stu-id="3407d-322">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="3407d-323">Alle Benutzer einer Cache Instanz sollten das gleiche Einheitensystem verwenden.</span><span class="sxs-lookup"><span data-stu-id="3407d-323">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="3407d-324">Ein Eintrag wird nicht zwischengespeichert, wenn die Summe der zwischengespeicherten Eintrags Größen den von angegebenen Wert überschreitet `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="3407d-324">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="3407d-325">Wenn keine Cache Größenbeschränkung festgelegt ist, wird die für den Eintrag festgelegte Cache Größe ignoriert.</span><span class="sxs-lookup"><span data-stu-id="3407d-325">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="3407d-326">Der folgende Code wird `MyMemoryCache` mit dem Container für die [Abhängigkeitsinjektion](xref:fundamentals/dependency-injection) registriert.</span><span class="sxs-lookup"><span data-stu-id="3407d-326">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/sample/RPcache/Startup.cs?name=snippet&highlight=5)]

<span data-ttu-id="3407d-327">`MyMemoryCache`wird als unabhängiger Speicher Cache für Komponenten erstellt, die diesen Größen eingeschränkten Cache beachten, und wissen, wie die Größe des Cache Eintrags entsprechend festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="3407d-327">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="3407d-328">Der folgende Code verwendet `MyMemoryCache` :</span><span class="sxs-lookup"><span data-stu-id="3407d-328">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet)]

<span data-ttu-id="3407d-329">Die Größe des Cache Eintrags kann nach [Größe](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) oder der Erweiterungsmethode [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) festgelegt werden:</span><span class="sxs-lookup"><span data-stu-id="3407d-329">The size of the cache entry can be set by [Size](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) or the [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) extension method:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="3407d-330">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="3407d-330">MemoryCache.Compact</span></span>

<span data-ttu-id="3407d-331">`MemoryCache.Compact`versucht, den angegebenen Prozentsatz des Caches in der folgenden Reihenfolge zu entfernen:</span><span class="sxs-lookup"><span data-stu-id="3407d-331">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="3407d-332">Alle abgelaufenen Elemente.</span><span class="sxs-lookup"><span data-stu-id="3407d-332">All expired items.</span></span>
* <span data-ttu-id="3407d-333">Elemente nach Priorität.</span><span class="sxs-lookup"><span data-stu-id="3407d-333">Items by priority.</span></span> <span data-ttu-id="3407d-334">Elemente der niedrigsten Priorität werden zuerst entfernt.</span><span class="sxs-lookup"><span data-stu-id="3407d-334">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="3407d-335">Zuletzt verwendete Objekte.</span><span class="sxs-lookup"><span data-stu-id="3407d-335">Least recently used objects.</span></span>
* <span data-ttu-id="3407d-336">Elemente mit dem frühesten absoluten Ablauf.</span><span class="sxs-lookup"><span data-stu-id="3407d-336">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="3407d-337">Elemente mit der frühesten gleitenden Ablaufzeit.</span><span class="sxs-lookup"><span data-stu-id="3407d-337">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="3407d-338">Fixierte Elemente mit Priorität <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> werden nie entfernt.</span><span class="sxs-lookup"><span data-stu-id="3407d-338">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="3407d-339">Weitere Informationen finden Sie [unter Compact Source auf GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) .</span><span class="sxs-lookup"><span data-stu-id="3407d-339">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="3407d-340">Cache Abhängigkeiten</span><span class="sxs-lookup"><span data-stu-id="3407d-340">Cache dependencies</span></span>

<span data-ttu-id="3407d-341">Im folgenden Beispiel wird gezeigt, wie ein Cache Eintrag abläuft, wenn ein abhängiger Eintrag abläuft.</span><span class="sxs-lookup"><span data-stu-id="3407d-341">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="3407d-342"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>Dem zwischengespeicherten Element wird ein hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="3407d-342">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="3407d-343">Wenn `Cancel` für aufgerufen wird `CancellationTokenSource` , werden beide Cache Einträge entfernt.</span><span class="sxs-lookup"><span data-stu-id="3407d-343">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="3407d-344">Durch `CancellationTokenSource` die Verwendung von können mehrere Cache Einträge als Gruppe entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="3407d-344">Using a `CancellationTokenSource` allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="3407d-345">Mit dem `using` Muster im obigen Code erben Cache Einträge, die innerhalb des- `using` Blocks erstellt werden, Trigger und Ablauf Einstellungen.</span><span class="sxs-lookup"><span data-stu-id="3407d-345">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="3407d-346">Zusätzliche Hinweise</span><span class="sxs-lookup"><span data-stu-id="3407d-346">Additional notes</span></span>

* <span data-ttu-id="3407d-347">Bei Verwendung eines Rückrufs zum erneuten Auffüllen eines Cache Elements:</span><span class="sxs-lookup"><span data-stu-id="3407d-347">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="3407d-348">Mehrere Anforderungen können den zwischengespeicherten Schlüsselwert leer finden, da der Rückruf noch nicht abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="3407d-348">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="3407d-349">Dies kann dazu führen, dass mehrere Threads das zwischengespeicherte Element neu auffüllen.</span><span class="sxs-lookup"><span data-stu-id="3407d-349">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="3407d-350">Wenn ein Cache Eintrag verwendet wird, um einen anderen zu erstellen, kopiert das untergeordnete Element die Ablauf Token und zeitbasierten Ablauf Einstellungen des übergeordneten Eintrags.</span><span class="sxs-lookup"><span data-stu-id="3407d-350">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="3407d-351">Das untergeordnete Element ist nicht abgelaufen, wenn der übergeordnete Eintrag manuell entfernt oder aktualisiert wird.</span><span class="sxs-lookup"><span data-stu-id="3407d-351">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="3407d-352">Verwenden Sie [postevictioncallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) , um die Rückrufe festzulegen, die ausgelöst werden, nachdem der Cache Eintrag aus dem Cache entfernt wurde.</span><span class="sxs-lookup"><span data-stu-id="3407d-352">Use [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="3407d-353">Cache Update im Hintergrund</span><span class="sxs-lookup"><span data-stu-id="3407d-353">Background cache update</span></span>

<span data-ttu-id="3407d-354">Verwenden Sie einen [Hintergrunddienst](xref:fundamentals/host/hosted-services) wie <xref:Microsoft.Extensions.Hosting.IHostedService> zum Aktualisieren des Caches.</span><span class="sxs-lookup"><span data-stu-id="3407d-354">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="3407d-355">Der Hintergrunddienst kann die Einträge neu berechnen und Sie dann nur dann dem Cache zuweisen, wenn Sie bereit sind.</span><span class="sxs-lookup"><span data-stu-id="3407d-355">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="3407d-356">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="3407d-356">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end
